// item53
// Page : 261 타입스크립트 보다는 ECMAscript 기능을 사용하기

// 타입스크립트의 발전과 자바스크립트의 발전이 서로 싱크가 맞지 않는 부분이 있었다.
// 자바스크립트에는 존재하지않았던 클래스/이넘 등을 타입스크립트는 독자적으로 개발하였지만
// 자바스크립트가 점점 발전하면서 부족한 부분을 채워 나가기 시작했고,
// 자바스크립트가 새로운 기능을 지원하면 기능이 충돌할수 있으므로
//  타입스크립트는 타입기능만 발전시킨다는 원칙을 세우고 현재까지 이어지고 있습니다.

// 이러한 원칙이 세워지기 전에, 이미 사용하던 기능들이 있고, 이것들은 현재에서는 값 공간과 타입공간의 경계를 혼란스럽게 합니다.

enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}

let flavor = Flavor.CHOCOLATE;
console.log(flavor);
Flavor; // 자동완성 가능 (.을 찍으면 확인 가능)
Flavor[0]; // 값이 바닐라.

// 단순한 값 나열보다 실수가 적고 확실하기 때문에 일반적으로 enum 을 사용하는것 좋은 경우가 있습니다.
// 그렇지만 이넘이 가지는 문제를 알아보겠습니다.

// 숫자열거형(위 예제의 Flavor) 에 0,1,2 외의 다른 숫자가 할당되면 매우 위험합니다.
// 이 방법은 원래 비트플래그 구조를 표현하기 위해 설계되었기 때문입니다.

// 참조: 비트플래그 -> 변수의 최소 크기 단위는 1바이트 인데 1바이트는 8 비트로 구성 (8개의 칸으로 구성)
// 8 비트중 불리언처럼 1과 0만으로도 표현이 가능한 값을 저장하기에는 1바이트는 메모리의 낭비가 크기 때문에
// 8개의 칸을 모두 사용하기 위한 개념인것같은데 ..자세히 아시는분은 설명좀 부탁드리겠습니다.

// 아마 이러한 개념 때문에 무작위 숫자가 들어오는게 문제가 된다고 한것같습니다.

// 상수 열거형은 보통의 열거형과 다르게 런타임에서 완전히 제거 됩니다. 만약 앞의 에제가 const enum Flavor 였다면
// 초코렛은 0이 될것이며, 이는 전혀 의도하지 않은 동작입니다.


let flav = Flavor.CHOCOLATE; // 이렇게 객체에 접근하는듯한 방식을는 사용할수 있지만.
flav = "CHOCOLATE"; // 이것은 타입 에러가 발생합니다.

// 함수를 사용할때도 이해하기 어려운 동작이 있습니다.
function scoop(flav: Flavor) {
  //..
}

// 해당 enum 은 런타임에는 string 이기 때문에 아래와 같아도 문제가 없지만
scoop("CHOCOLATE"); // ts 에서는 이렇게 사용하는것은 타입 에러가 발생합니다.

scoop(Flavor.CHOCOLATE); // 이렇게 사용하는것은 문제가 없지만
// 이렇게사용하는것은 라이브러리를 공개할때 사용될수 있습니다.

// 문자열 열거형을 사용하고싶다면 스트링 리터럴 유니온을 사용하면됩니다.
// 열거형만큼 안전하며 자바스크립트와 바로 호환됩니다.

// 매개변수에 대한 문법

// 자바스크립트 클래스
class Peerson {
  name: string;
  constructor(name: string) {
    this.name = name;
  }
}

// ts 의 클래스
class peerson2 {
  constructor(public name: string) {}
} // 참조: 저는 이렇게 해본적 없는것같습니다. 클래스를 잘 안쓸뿐더러.. 매개변수에 퍼블릭/ 스태틱등을 붙여본일도업네용...ㅎ

// ts 를 활용한 클래스의 문제는 아래와 같습니다.

// 일반적으로 타입스크립트는 런타임에 삭제되어 코드가 줄어들지만 위예제의 코드는 코드를 늘리게 됩니다.
// 매개변수 속성이 런타임에는 실제로 사용 되지만 ts관점에서는 사용되지 않느것처럼 보입니다.
// 일반 속성과 매개변수 속성이 섞여 사용되면 설계가 어지럽습니다.

class peerson3 {
  firstName: string;
  lastName: string;
  constructor(public name: string) {
    [this.firstName, this.lastName] = name.split(" ");
  }
} // 이 예제는 실제로 firstName, lastName, Name 총 3개의 속성을 가지고 있지만 겉보기에는 2개로 보이는 문제가 있습니다.

// 구조적 타이핑 관점에서 다음처럼 사용할수도 있다는 문제가 있습니다.
class peerson4 {
  constructor(public name: string) {}
}
const p4: peerson4 = {
  name: "Jane",
}; // 클래스는 인터페이스나 타입처럼 사용가능합니다. 책의 앞부분에서는 클래스는 런타임에 타입을 유지할수있는 수단이라 하였기 때문에
// 구지 잘못이라고 보이지는 않습니다만 클래스 선언 자체가 ts 문법인것은 약간 거슬리긴합니다.

// 클래스 매개변수 속성에 대한것은 좋고 나쁜것에 대한 의견이 갈린다고 합니다.
// 클래스 매개변수 속성은 ts 의 다른 문법과 이질적이고, 초급자에게 생소합니다.

// 트리플슬래시 (///) 임포트  (/// <reference path="somePath" />) 와 네임스페이스
//ECMAScript 2015 이전에는 js 에 모듈시스템이 없었기 때문에  노드는 require , module.exports 를 사용하였습니다.
// 이 시기에 ts 는 자체적인 모듈 시스템을 구축했고, 이제는 이 문법은 더이상 사용되지 않습니다. 호환성을 위해서만 남아 있을 뿐입니다.

// 데코레이터
// 클래스/ 매서드 속성 위에 애노테이션을 붙일수있습니다.
class exex {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }

  @logged
  static run() {
    console.log("run");
  }
}

function logged(target: any, name: string, descriptor: any) {
  console.log(name);
}

// 이러한 데코레이터는 처음에 앵귤러를 지원하기 위해서 추가된것입니다.
// tsconfig 에 expreimentalDecorators 속성을 설정해야합니다.
// 아직 표준화가 완료되지 않았기 때문에 사용중인 데코레이터가 비표준이 되거나 호환이 깨질수있기때문에 사용을 하지 않는게 좋습니다.

// 요약
// ts 는 일반적으로 트랜스파일 이후 자바스크립트가 되지만 열거형, 매개변수 속성, 트리플슬래시, 데코레이터 등은 자바스크립트로 변환되지 않습니다.
// 위에 나열된것들은 사용하지 않는것이 ts 를 더 역할에 맞게 사용하는것입니다.


