// Item 44
// Page : 224 타입 커버리지를 추적하여 타입 안전성 유지하기

// noimplicitany 옵션을 사용한다고 하더라도 any 타입과 관련된 문제들로부터 안전하다고 확신할 수 없습니다.
// any 타입은 다음과 같은 경우에 프로그램 내에 존재할 수 있습니다.

// 1 명시적 any타입. // 암시적 any 가 아니므로 명시적인 any 는 프로그램 내에 존재할 수 있게 됩니다.

// 2. 서드파티 타입
// @types 파일로 부터 any 타입이 들어올 수 있습니다.

// 프로제트에서 any 의 갯수를 추적할 수 있습니다.
// npx type-coverage // 명령어를 사용하면 프로젝트의 타입커버리지를 확인할 수 있습니다

// 9985 / 10117 98.69%    전체 프로그램의 98.96 퍼센트가 any 가 아니거나 any 의 별칭이 아닌 타입을 가진다는 뜻입니다.
// any 가 많아 질수록 백분율은 감소합니다.

// npx type-corverage --detail 플래그를 붙이면 any 가 위치한 파일도 출력해줍니다.
// 미처 발견하지 못한 any 를 찾을수도 있습니다.

// any 가 프로그램에 남아 있는 이유는 다양할 수 있습니다.
// 타입 오류를 해결하기 위한 시간이 부족했을수도 있습니다.  타입 작성이 불완전하기 때문일수도 있습니다.

// 다음 예시를 보겠습니다.

// 어떤 함수 내부에서 사용하는 함수의 리턴값이 any 이기 때문에 해당함수의 리턴타입을 any 로 명시했었습니다.
function returnAny(b: string): any {
  // 예를들어 아래 함수가 외부 라이브러리 이고, 리턴값이 any 라고 한다면,
  const someFn2 = (a: string): any => {};
  return someFn2(b);
}

// 해당 라이브러리 함수의 리턴 타입을 개선했다고 했을떄/
function returnAny3(b: string): any {
  const someFn2 = (a: string): string => {
    return a;
  };
  return someFn2(b);
} // 아직 이 함수의 리턴값은 any 이므로, 최종적으로 any 타입을 리턴합니다.

// 이런 경우 라이브러리가 추후 업데이트 되면 any 를 제거해 주어야 합니다.

//요약
// 암시적 any 허용을 금지하여도, any 는 얼마든지프로그램에 남아 있을 수 있습니다.
